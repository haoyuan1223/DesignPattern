# Head First Design Pattern
## Chapter01 Strategy Pattern
定义算法族，分别封装起来，让他们之间可以相互替换，策略模式让算法的变化独立于使用算法的用户。
## Chapter02 Observer Pattern
定义对象之间一对多的依赖关系，当被依赖对象的状态改变时，所有依赖对象能自动收到更新并改变自己。
## Chapter03 Decoration Pattern
动态地将责任附加到对象上，若要扩展功能，装饰者模式提供不同于继承的另一种选择。
## Chapter04 Factory Pattern
### Factory Method
定义了一个创建对象的接口，但由子类决定实例化哪一个类。工厂方法让类的实例化推迟到子类。
### Abstract Factory
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定的类。
## Chapter05 Singleton Pattern
确保一个类只有一个实例，并提供全局访问点。
1. 懒汉式
2. 饿汉式
3. 双重检查加锁
## Chapter06 Command Pattern
将请求封装成对象，以便参数化、重做和撤销等操作。
## Chapter07 Adapter Pattern and Facade Pattern
### Adapter Pattern
适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  
两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。
### Facade Pattern
外观模式为子系统中的一组接口提供了统一的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。  
外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。
## Chapter08 Template Pattern
在一个方法中定义算法框架，而将一些步骤延迟到子类中实现。模版方法使得子类在不改变算法结构的前提下，重新定义算法中的某些步骤。
## Chapter09 Iterator Pattern and Composite Pattern
### Iterator Pattern
迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
### Composite Pattern
将对象组成树形结构来表现"整体/部分"的层次结构。组合让客户以相同的方式处理个别对象和对象组合。
## Chapter10 State Pattern
对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
## Chapter11 Proxy Pattern
为另一个对象提供一个替身或者占位符以控制对这个对象的访问。
1. 远程代理：可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转发给客户。
2. 虚拟代理：作为创建开销大的对象的代表。虚拟代理常常直到我们真正需要一个对象的时候才创建它。在对象创建之前，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。
3. 保护代理：根据访问权限决定客户可否访问对象的代理。
4. 防火墙代理：控制网络资源的访问。
5. 智能引用代理：当对象被引用时，进行额外的操作，例如访问计数。
6. 缓存代理：为开销大的运算结果提供暂时的存储：允许多个客户之间共享结果，以减少网络延迟和计算耗时。
7. 同步代理：在多线程的条件下提供安全对象的安全访问。
8. 复杂隐藏代理：隐藏一个类的复杂集合的复杂度，并进行访问控制。有时也称为"外观代理"。
9. 写入时复制代理：控制对象的复制，方法是延迟对象的复制，直到真正需要时才复制，这是虚拟代理的变体。